\documentclass{article}

%%%%%%%%%%%%%%
%%%%%%%%%%%%%%
%% Template 

%% END TEMPLATE
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%
% Our formatting rules and included packages.
%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Recommended by the ACM ppl
\usepackage{booktabs}
\usepackage{subcaption}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Our packages
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage[all]{xy}

%% Cleveref must be the last loaded package
%% since it modifies the cross-ref system.
\usepackage{cleveref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Our defs

\theoremstyle{definition}
\newtheorem{mydef}{Definition}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

%% Drawing patches using tikz
\newenvironment{twothreetree}{%
\begin{tikzpicture}[%
  sibling distance=3em,
  innernode/.style = {rectangle , draw},
  leafnode/.style = { } ,
  subtree/.style = {regular polygon , regular polygon sides=3 , draw , scale=0.2} ]%
}{%
\end{tikzpicture}%
}

%% More space between rows
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}

%% Logistic Stuff

\definecolor{C1}{RGB}{0,153,204}
\definecolor{C2}{RGB}{89,0,179}

\newcounter{commentctr}[section]
\setcounter{commentctr}{0}
\renewcommand{\thecommentctr}{%
\arabic{section}.\arabic{commentctr}}

\newcommand{\warnme}[1]{%
{\color{red} \textbf{$[$} #1 \textbf{$]$}}}

\newcommand{\TODO}[1]{%
{\color{purple} \textbf{$[$ TODO: } #1 \textbf{$]$}}}

\newcommand{\tmp}[1]{%
{\color{gray} \textit{#1} }}

\newenvironment{temp}{\bgroup \color{gray} \textit}{\egroup}

\newcommand{\victor}[2][nolabel]{%
{\color{C2} \refstepcounter{commentctr}\label{#1} \textbf{$[$ (\thecommentctr) Victor: } #2 \textbf{$]$}}}

%% LaTeX stuff

\newenvironment{myhs}{\par\vspace{0.15cm}\begin{minipage}{\textwidth}}{\end{minipage}\vspace{0.15cm}}

%% Repository
%%   https://github.com/VictorCMiraldo/hs-digems
\newcommand{\hsdigemsgit}[0]{https://github.com/VictorCMiraldo/hs-digems}

\newcommand{\bigO}[1]{\mathcal{O}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% lhs2TeX Formatting Rules
%%
%% Comment out to use lhs2TeX default formatting.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%% Haskell Styling
%%
%% TODO: Figure out spacing!

%% Colors (from duo-tone light syntax)
\definecolor{hsblack}{RGB}{45,32,3}
\definecolor{hsgold1}{RGB}{179,169,149}
\definecolor{hsgold2}{RGB}{177,149,90}
\definecolor{hsgold3}{RGB}{190,106,13}%{192,96,4}%{132,97,19}
\definecolor{hsblue1}{RGB}{173,176,182}
\definecolor{hsblue2}{RGB}{113,142,205}
\definecolor{hsblue3}{RGB}{0,33,132}
\definecolor{hsblue4}{RGB}{97,108,132}
\definecolor{hsblue5}{RGB}{34,50,68}
\definecolor{hsred2}{RGB}{191,121,103}
\definecolor{hsred3}{RGB}{171,72,46}

%% LaTeX Kerning nastiness. By using curly braces to delimit color group,
%% it breaks spacing. The following seems to work:
%%
%% https://tex.stackexchange.com/questions/85033/colored-symbols/85035#85035
%%
\newcommand*{\mathcolor}{}
\def\mathcolor#1#{\mathcoloraux{#1}}
\newcommand*{\mathcoloraux}[3]{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\newcommand{\HSKeyword}[1]{\mathcolor{hsgold3}{\textbf{#1}}}
\newcommand{\HSNumeral}[1]{\mathcolor{hsred3}{#1}}
\newcommand{\HSChar}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSString}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSSpecial}[1]{\mathcolor{hsblue4}{\ensuremath{#1}}}
\newcommand{\HSSym}[1]{\mathcolor{hsblue4}{\ensuremath{#1}}}
\newcommand{\HSCon}[1]{\mathcolor{hsblue3}{#1}}
\newcommand{\HSVar}[1]{\mathcolor{hsblue5}{\mathit{\ensuremath{#1}}}}
\newcommand{\HSComment}[1]{\mathcolor{hsgold2}{\textit{#1}}}


%%% lhs2TeX parser does not recognize '*' 
%%% in kind annotations, it thinks it is a multiplication.


%%

% Easy to typeset Haskell types using the 
% commands from stylish.lhs (if it's defined!)
\newcommand{\HT}[1]{\ifdefined\HSCon\HSCon{#1}\else#1\fi}
\newcommand{\HS}[1]{\ifdefined\HSSym\HSSym{#1}\else#1\fi}
\newcommand{\HV}[1]{\ifdefined\HSVar\HSVar{#1}\else#1\fi}

%%% Datatype Promotion

%%% Usefull Notation

%% Formatting type-applications


%% Words with wrong kerning
%
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% Title information
\title{The Case Against Edit Scripts}
\author{Victor Cacciari Miraldo}
%%\affiliation{
%%  \position{PhD candidate}
%%  \department{Information and Computing Sciences}
%%  \institution{Utrecht University}
%%  \streetaddress{Princetonplein, 5}
%%  \city{Utrecht}
%%  \state{Utrecht}
%%  \postcode{3584 CC}
%%  \country{The Netherlands} 
%%}
%%\email{v.cacciarimiraldo@@uu.nl}
%
%%\author{Wouter Swierstra}
%%\affiliation{
%%  \position{Assistant Professor}
%%  \department{Information and Computing Sciences}
%%  \institution{Utrecht University}
%%  \streetaddress{Princetonplein, 5}
%%  \city{Utrecht}
%%  \state{Utrecht}
%%  \postcode{3584 CC}
%%  \country{The Netherlands} 
%%}
%%\email{w.s.swierstra@@uu.nl}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%
% Body
%
\section{Introduction}

Edit scripts are bad.
\victor{
\begin{itemize}
  \item Too much redundancy implies expensive algorithms.
  \item Too restrictive on opeations implies not being able to duplicate or permute.
  \item When coupled with line-based diff, merges are bad.
  \item Show a couple examples.
\end{itemize}}

We propose an extensional approach.

\section{Background}

\victor{Some edit-scripts; some about tree-diffing}

\victor{Primer on unification and substitution and term algebras}

\section{Extensional Patches}

  Instead of linearizing trees and relying on very local operations
such as insertion, deletions and copying of a single constructor, 
we can take the extensional look over patches and describe them by a mapping
between sets of trees. Lets look at a simple patch that deletes
the left subtree of a binary tree -- which
can be described by the \ensuremath{\HSCon{Del}\;\HSCon{Bin}\;\HSSpecial{(}\HSCon{Del}\;\HS{\dots}\;\HSSpecial{(}\HSCon{Cpy}\;\HS{\dots}\;\HSCon{Nil}\HSSpecial{)}\HSSpecial{)}} edit script.
A Haskell function that performs that operation can be given by:

\begin{myhs}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{delL}\;\HSSpecial{(}\HSCon{Bin}\;\HSSym{\anonymous} \;\HSVar{x}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Just}\;\HSVar{x}{}\<[E]%
\\
\>[B]{}\HSVar{delL}\;\HSSym{\anonymous} {}\<[16]%
\>[16]{}\HSSym{\mathrel{=}}\HSCon{Nothing}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{myhs}

  The \ensuremath{\HSVar{delL}} function specifies a domain -- those trees with a \ensuremath{\HSCon{Bin}} at their root --
and a transformation, which forgets the root and its left child.


\victor{still deciding the order of examples here... this is messy; pardon}


Take the patch that swaps the children of a binary tree
-- which is already impossible to represent with edit-scripts. It could be represented
by a Haskell function \ensuremath{\HSVar{swap}}:

\begin{myhs}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{swap}\;\HSSpecial{(}\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Just}\;\HSSpecial{(}\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{swap}\;\HSSym{\anonymous} {}\<[16]%
\>[16]{}\HSSym{\mathrel{=}}\HSCon{Nothing}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{myhs}

  This \ensuremath{\HSVar{swap}} function has a pattern, which identifies the domain of
the function. In our case, we can only swap trees with a \ensuremath{\HSCon{Bin}} constructor
at the root. That is, \ensuremath{\HSVar{dom}\;\HSVar{swap}} is given by:

\begin{myhs}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{dom}\;\HSVar{swap}\HSSym{\mathrel{=}}\HSSpecial{\HSSym{\{\mskip1.5mu} }\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}\HSSym{\mid} \HSVar{x}\HSSym{\in} \HSCon{Tree}\HSSpecial{,}\HSVar{y}\HSSym{\in} \HSCon{Tree}\HSSpecial{\HSSym{\mskip1.5mu\}}}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{myhs}

\victor{Onto patches}

\newcommand{\termsof}[1]{\ensuremath{\mathcal{T}_{#1}}}
\newcommand{\patch}[2]{\ensuremath{#1 \mapsto #2}}
\newcommand{\pdel}[1]{\ensuremath{{#1}_d}}
\newcommand{\pins}[1]{\ensuremath{{#1}_i}}
\newcommand{\vars}[1]{\ensuremath{\mathbf{vars}\;#1}}
\newcommand{\app}[2]{\ensuremath{\mathbf{app}\;#1\;#2}}
\newcommand{\mgu}{\ensuremath{\mathbf{mgu}}}
\newcommand{\appAlpha}[3][\alpha]{\ensuremath{\mathbf{app}_{#1}\;#2\;#3}}

\newcommand{\after}[2]{\ensuremath{#1 \mathbin{\circ} #2}}


\begin{mydef}
  Let $\termsof{L}$ be the term algebra for the language $L$ augmented
with a countable set $V$ of variables. A patch $p =
\patch{\pdel{p}}{\pins{p}}$ consists in a pattern, $\pdel{p}$, and an
expression, $\pins{p}$ --- both elements of $\termsof{L}$ --- such
that $\vars{\pins{p}} \subseteq \vars{\pdel{p}}$.  We sometimes refer
to $\pdel{p}$ and $\pins{p}$ as the deletion and insertion contexts of
$p$.
\end{mydef}

\begin{mydef}
  We say an element $x \in \termsof{L}$ is a \emph{term} whenever 
$\vars{x} = \emptyset$.
\end{mydef}

  The \emph{swap} patch, for example, is represented by \ensuremath{\patch{\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}}{\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}}}, where \ensuremath{\HSVar{x}} and \ensuremath{\HSVar{y}} are taken from the set $V$ of variables.
Similarly to working with the $\lambda$-calculus, we
assume variable names never clash between patches.

\begin{mydef} 
\victor{application}
  Let $p$ be a patch over $\termsof{L}$ and $x$ a term over $\termsof{L}$,
we say $p$ applies to $x$ whenever $\pdel{p}$ unifies with $x$. Let
$\alpha$ be such substitution, the result of the application is $\alpha\;\pins{p}$.

\[ \app{p}{x} = y \iff \exists \alpha . \alpha\;\pdel{x} = \alpha\;x \wedge \alpha\;\pins{p} = y \]
\end{mydef}

  The identity patch is simply \ensuremath{\patch{\HSVar{x}}{\HSVar{x}}}. 

\begin{lemma}
\victor{correctness of application}
  For all patch $p$ and term $x$, if $\app{p}{x} = y$ then $y$ is a term.
\end{lemma}
\begin{proof}
todo
\end{proof}

  This notion of application gives rise to an extensional equality of patches.
We say patches $p$ and $q$ are equal, denoted $p \approx q$, whenever 
\[ \forall x . (\app{p}{x} = y \iff \app{q}{x} = z) \wedge y = z \]
It is easy to prove that $\approx$ above gives an equivalence relation.

\begin{mydef}
\victor{composition}
  Let $p$ and $q$ be patches we say that $p$ and $q$ compose whenever
$\pdel{p}$ unifies with $\pins{q}$ --- let $\sigma$ be such mgu. 
Given two patches $p$ and $q$ that compose,

\ensuremath{\after{\HSVar{p}}{\HSVar{q}}\HSSym{\mathrel{=}}\patch{\HSVar{sigma}\;\pdel{\HSVar{q}}}{\HSVar{sigma}\;\pins{\HSVar{p}}}}
\end{mydef}

\begin{lemma}
\victor{composition is correct}
  Given $p$ and $q$ composable patches, \ensuremath{\app{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{x}}\HSSym{\mathrel{=}}\HSVar{z}} iff \ensuremath{\app{\HSVar{q}}{\HSVar{x}}\HSSym{\mathrel{=}}\HSVar{y}\HSSym{\mathrel{\wedge}}\app{\HSVar{p}}{\HSVar{y}}\HSSym{\mathrel{=}}\HSVar{z}}.
\end{lemma}
\begin{proof}
transcribe from notebook
\end{proof}

\begin{lemma}
For any patch $p$, the identity patch \ensuremath{\patch{\HSVar{x}}{\HSVar{x}}} is a left and right
identity to patch composition.
\end{lemma}
\begin{proof}
trivial
\end{proof}

\begin{lemma}
  Given $p$ and $q$ composable patches, let $\sigma = \mgu(\pdel{p} , \pins{q})$,
then there exists $\sigma_p, \sigma_q$ such that $\sigma = \sigma_p \cup \sigma_q$ and
$\sigma_p \; \pdel{p} = \sigma_q \; \pins{q}$.
\end{lemma}
\begin{proof}
Immediate since $\vars{p} \cap \vars{q} = \emptyset$.
\end{proof}

\begin{lemma}
  Given $p$ and $q$ composable patches, let $\sigma = \mgu(\pdel{p} , \pins{q})$,
then $\sigma$ is idempodent in $\pdel{q}$ and $\pins{p}$. That is, $\sigma\;\sigma\;\pdel{q} = \sigma\;\pdel{q}$
and similarly for $\pins{p}$.
\end{lemma}
\begin{proof}
transcribe
\end{proof}

  With these lemmas at hand, we can prove associativity of our
composition operator.

\begin{lemma}
Let $p$ and $q$ be composable patches. Let $r$ be a patch composable
with \ensuremath{\after{\HSVar{p}}{\HSVar{q}}}. Then, $q$ and $r$ are composable and $p$ and \ensuremath{\after{\HSVar{q}}{\HSVar{r}}}
are composable. Moreover, \ensuremath{\after{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{r}}\approx\after{\HSVar{p}}{\HSSpecial{(}\after{\HSVar{r}}{\HSVar{q}}\HSSpecial{)}}}
\end{lemma}
\begin{proof}
transcribe from notebook; somewhat long.
\end{proof}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: 
%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

%% Bibliography
\bibliography{references}
\end{document}
