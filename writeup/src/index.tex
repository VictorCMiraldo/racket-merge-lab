\documentclass{article}

%%%%%%%%%%%%%%
%%%%%%%%%%%%%%
%% Template 

%% END TEMPLATE
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%
% Our formatting rules and included packages.
%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Recommended by the ACM ppl
\usepackage{booktabs}
\usepackage{subcaption}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Our packages
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage[all]{xy}

%% Cleveref must be the last loaded package
%% since it modifies the cross-ref system.
\usepackage{cleveref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Our defs

\theoremstyle{definition}
\newtheorem{mydef}{Definition}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lemma}{Lemma}

%% Drawing patches using tikz
\newenvironment{twothreetree}{%
\begin{tikzpicture}[%
  sibling distance=3em,
  innernode/.style = {rectangle , draw},
  leafnode/.style = { } ,
  subtree/.style = {regular polygon , regular polygon sides=3 , draw , scale=0.2} ]%
}{%
\end{tikzpicture}%
}

%% More space between rows
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}

%% Logistic Stuff

\definecolor{C1}{RGB}{0,153,204}
\definecolor{C2}{RGB}{89,0,179}

\newcounter{commentctr}[section]
\setcounter{commentctr}{0}
\renewcommand{\thecommentctr}{%
\arabic{section}.\arabic{commentctr}}

\newcommand{\warnme}[1]{%
{\color{red} \textbf{$[$} #1 \textbf{$]$}}}

\newcommand{\TODO}[1]{%
{\color{purple} \textbf{$[$ TODO: } #1 \textbf{$]$}}}

\newcommand{\tmp}[1]{%
{\color{gray} \textit{#1} }}

\newenvironment{temp}{\bgroup \color{gray} \textit}{\egroup}

\newcommand{\victor}[2][nolabel]{%
{\color{C2} \refstepcounter{commentctr}\label{#1} \textbf{$[$ (\thecommentctr) Victor: } #2 \textbf{$]$}}}

%% LaTeX stuff

\newenvironment{myhs}{\par\vspace{0.15cm}\begin{minipage}{\textwidth}}{\end{minipage}\vspace{0.15cm}}

%% Repository
%%   https://github.com/VictorCMiraldo/hs-digems
\newcommand{\hsdigemsgit}[0]{https://github.com/VictorCMiraldo/hs-digems}

\newcommand{\bigO}[1]{\mathcal{O}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% lhs2TeX Formatting Rules
%%
%% Comment out to use lhs2TeX default formatting.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%% Haskell Styling
%%
%% TODO: Figure out spacing!

%% Colors (from duo-tone light syntax)
\definecolor{hsblack}{RGB}{45,32,3}
\definecolor{hsgold1}{RGB}{179,169,149}
\definecolor{hsgold2}{RGB}{177,149,90}
\definecolor{hsgold3}{RGB}{190,106,13}%{192,96,4}%{132,97,19}
\definecolor{hsblue1}{RGB}{173,176,182}
\definecolor{hsblue2}{RGB}{113,142,205}
\definecolor{hsblue3}{RGB}{0,33,132}
\definecolor{hsblue4}{RGB}{97,108,132}
\definecolor{hsblue5}{RGB}{34,50,68}
\definecolor{hsred2}{RGB}{191,121,103}
\definecolor{hsred3}{RGB}{171,72,46}

%% LaTeX Kerning nastiness. By using curly braces to delimit color group,
%% it breaks spacing. The following seems to work:
%%
%% https://tex.stackexchange.com/questions/85033/colored-symbols/85035#85035
%%
\newcommand*{\mathcolor}{}
\def\mathcolor#1#{\mathcoloraux{#1}}
\newcommand*{\mathcoloraux}[3]{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\newcommand{\HSKeyword}[1]{\mathcolor{hsgold3}{\textbf{#1}}}
\newcommand{\HSNumeral}[1]{\mathcolor{hsred3}{#1}}
\newcommand{\HSChar}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSString}[1]{\mathcolor{hsred2}{#1}}
\newcommand{\HSSpecial}[1]{\mathcolor{hsblue4}{\ensuremath{#1}}}
\newcommand{\HSSym}[1]{\mathcolor{hsblue4}{\ensuremath{#1}}}
\newcommand{\HSCon}[1]{\mathcolor{hsblue3}{#1}}
\newcommand{\HSVar}[1]{\mathcolor{hsblue5}{\mathit{\ensuremath{#1}}}}
\newcommand{\HSComment}[1]{\mathcolor{hsgold2}{\textit{#1}}}


%%% lhs2TeX parser does not recognize '*' 
%%% in kind annotations, it thinks it is a multiplication.


%%

% Easy to typeset Haskell types using the 
% commands from stylish.lhs (if it's defined!)
\newcommand{\HT}[1]{\ifdefined\HSCon\HSCon{#1}\else#1\fi}
\newcommand{\HS}[1]{\ifdefined\HSSym\HSSym{#1}\else#1\fi}
\newcommand{\HV}[1]{\ifdefined\HSVar\HSVar{#1}\else#1\fi}

%%% Datatype Promotion

%%% Usefull Notation

%% Formatting type-applications


%% Words with wrong kerning
%
%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% Title information
\title{The Case Against Edit Scripts}
\author{Victor Cacciari Miraldo}
%%\affiliation{
%%  \position{PhD candidate}
%%  \department{Information and Computing Sciences}
%%  \institution{Utrecht University}
%%  \streetaddress{Princetonplein, 5}
%%  \city{Utrecht}
%%  \state{Utrecht}
%%  \postcode{3584 CC}
%%  \country{The Netherlands} 
%%}
%%\email{v.cacciarimiraldo@@uu.nl}
%
%%\author{Wouter Swierstra}
%%\affiliation{
%%  \position{Assistant Professor}
%%  \department{Information and Computing Sciences}
%%  \institution{Utrecht University}
%%  \streetaddress{Princetonplein, 5}
%%  \city{Utrecht}
%%  \state{Utrecht}
%%  \postcode{3584 CC}
%%  \country{The Netherlands} 
%%}
%%\email{w.s.swierstra@@uu.nl}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%
% Body
%
\newcommand{\termsof}[1]{\ensuremath{\mathcal{T}_{#1}}}
\newcommand{\patch}[2]{\ensuremath{#1 \mapsto #2}}
\newcommand{\pdel}[1]{\ensuremath{\mathbf{del}\;{#1}}}
\newcommand{\pins}[1]{\ensuremath{\mathbf{ins}\;{#1}}}
\newcommand{\vars}[1]{\ensuremath{\mathbf{vars}\;#1}}
\newcommand{\app}[2]{\ensuremath{\mathbf{app}\;#1\;#2}}
\newcommand{\comp}[2]{\ensuremath{\mathbf{comp}\;#1\;#2}}
\newcommand{\mgu}{\ensuremath{\mathbf{mgu}}}
\newcommand{\appAlpha}[3][\alpha]{\ensuremath{\mathbf{app}_{#1}\;#2\;#3}}
\newcommand{\after}[2]{\ensuremath{#1 \mathbin{\bullet} #2}}






\section{Introduction}

Edit scripts are bad.
\victor{
\begin{itemize}
  \item Too much redundancy implies expensive algorithms.
  \item Too restrictive on opeations implies not being able to duplicate or permute.
  \item When coupled with line-based diff, merges are bad.
  \item Show a couple examples.
\end{itemize}}

We propose an extensional approach.

\section{Background}

\victor{Some edit-scripts; some about tree-diffing}

\victor{Primer on unification and substitution and term algebras}

\section{Algebra of Extensional Patches}

  Instead of linearizing trees and relying on very local operations
such as insertion, deletions and copying of a single constructor, we
can take an extensional look over patches: describing patches
directly as a partial map. Take the patch that deletes
the left subtree of a binary tree -- which can be described by the
\ensuremath{\HSCon{Del}\;\HSCon{Bin}\;\HSSpecial{(}\HSCon{Del}\;\HS{\dots}\;\HSSpecial{(}\HSCon{Cpy}\;\HS{\dots}\;\HSCon{Nil}\HSSpecial{)}\HSSpecial{)}} edit script.  A Haskell function
that performs that operation can be given by:

\begin{myhs}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{delL}\;\HSSpecial{(}\HSCon{Bin}\;\HSSym{\anonymous} \;\HSVar{x}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Just}\;\HSVar{x}{}\<[E]%
\\
\>[B]{}\HSVar{delL}\;\HSSym{\anonymous} {}\<[16]%
\>[16]{}\HSSym{\mathrel{=}}\HSCon{Nothing}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{myhs}

  The \ensuremath{\HSVar{delL}} function specifies a domain -- those trees with a \ensuremath{\HSCon{Bin}}
at their root -- and a transformation, which forgets the root and its
left child, returning only the right child of the root. One way of
representing this is by \ensuremath{\patch{\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}}{\HSVar{x}}}, where \ensuremath{\HSVar{x}} and \ensuremath{\HSVar{y}} are variables,
which are bound on the \emph{deletion context} of the patch and
used on the \emph{insertion context} of the patch.
\victor{the ES variant fixes the left subtree; we can make it
in such a way that we don't... I need to really figure the 
details of this before writing it up though.}

  Let us look at another example: the patch that swaps the children of
a binary tree -- which is already impossible to represent with
edit-scripts. It could be represented by a Haskell function below,
or by \ensuremath{\patch{\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}}{\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}}}.

\begin{myhs}
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\HSVar{swap}\;\HSSpecial{(}\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}\HSSpecial{)}\HSSym{\mathrel{=}}\HSCon{Just}\;\HSSpecial{(}\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}\HSSpecial{)}{}\<[E]%
\\
\>[B]{}\HSVar{swap}\;\HSSym{\anonymous} {}\<[16]%
\>[16]{}\HSSym{\mathrel{=}}\HSCon{Nothing}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{myhs}

  In the examples above, we have informally described extensional patches
over a simple \emph{term algebra}, namelly, that of binary trees
with \ensuremath{\HSCon{Bin}} and \ensuremath{\HT{Lea\!f}}. Next we explore this notion of patches
for arbitrary term algebras and, in the remainder of the section,
discuss a composition and inverse notion that gives rise to
a grupoid structure.

  Because we need the notion of variable to specify our
deletion and insertion contexts, we will work with the usual
term algebra, but augmented with a countable set $V$ of variables.
That is, let $L$ be a language, we denote by $\termsof{L}$ the set of
terms over $L$ augmented with the set $V$ of variables. For
any $t \in \termsof{L}$, $\vars{t} \subseteq V$ denotes the
variables in $t$. When $\vars{t} = \emptyset$, we say $t$
is a \emph{term}.

\begin{mydef}[Patch]
  Let $L$ be a language, a patch \ensuremath{\HSVar{p}} consists in any element of
$\termsof{L} \times \termsof{L}$ such that \ensuremath{\vars{\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}\;\subseteq\;\HSSpecial{(}\vars{\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}}\HSSpecial{)}}, where \ensuremath{\pdel{\HSVar{p}}} and \ensuremath{\pins{\HSVar{p}}} ared \ensuremath{\pins{\HSVar{p}}} and second are
the first and second projections, respectivelly.
Given two elements \ensuremath{\HSVar{d}\HSSpecial{,}\HSVar{i}} of $\termsof{L}$, we denote a patch
as \ensuremath{\patch{\HSVar{d}}{\HSVar{i}}}.
\end{mydef}

  As usual when working with binders and variables, we assume that
variable name clashes between two patches. Application of a patch to a
term is easily defined with the help of unification.  Take the \ensuremath{\HSVar{swap}}
patch, \ensuremath{\patch{\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}}{\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}}}, and the tern \ensuremath{\HSVar{t}\HSSym{\mathrel{=}}\HSCon{Bin}\;\HT{Lea\!f}\;\HSSpecial{(}\HSCon{Bin}\;\HT{Lea\!f}\;\HT{Lea\!f}\HSSpecial{)}}. First we must unify the deletion context wiht \ensuremath{\HSVar{t}}, which
yields the substitution \ensuremath{\HSVar{x}\HSSym{\mathrel{=}}\HT{Lea\!f}\HSSym{\mathrel{\wedge}}\HSVar{y}\HSSym{\mathrel{=}}\HSCon{Bin}\;\HT{Lea\!f}\;\HT{Lea\!f}}. To get
the result, we must apply this substitution to the insertion context
of our patch. 

\begin{mydef}[Application] 
  Let $p$ be a patch over $\termsof{L}$ and $t$ a term over $\termsof{L}$,
we say \ensuremath{\HSVar{p}} applies to \ensuremath{\HSVar{t}} whenever \ensuremath{\pdel{\HSVar{p}}} unifies with \ensuremath{\HSVar{t}}. 
Let \ensuremath{\HV{\alpha}} be such substitution, the result of the application is 
\ensuremath{\HV{\alpha}\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}. We define the relation \ensuremath{\app{\HSVar{p}}{\HSVar{t}}\;\HSVar{u}} to captures exactly that.
\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\app{\HSVar{p}}{\HSVar{t}}\;\HSVar{u}\triangleq\exists\;\HV{\alpha}\;.\;\HSSpecial{(}\HV{\alpha}\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}\HSSym{\equiv} \HV{\alpha}\;\HSVar{t}\HSSpecial{)}\HSSym{\mathrel{\wedge}}\HV{\alpha}\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}\HSSym{\equiv} \HSVar{u}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
We often abuse notation and write \ensuremath{\app{\HSVar{p}}{\HSVar{t}}\HSSym{\mathrel{=}}\HSVar{u}} instead of \ensuremath{\app{\HSVar{p}}{\HSVar{t}}\;\HSVar{u}}.
\end{mydef}
 
\begin{lemma}
For all patch \ensuremath{\HSVar{p}}, term \ensuremath{\HSVar{t}} and \ensuremath{\HSVar{u}}$\in \termsof{L}$, if \ensuremath{\app{\HSVar{p}}{\HSVar{t}}\HSSym{\mathrel{=}}\HSVar{u}}, then
\ensuremath{\HSVar{u}} is a term, that is, \ensuremath{\vars{\HSVar{u}}\HSSym{\equiv} \emptyset}.
\end{lemma}
\begin{proof}
  Let \ensuremath{\HV{\alpha}} be the witness of \ensuremath{\app{\HSVar{p}}{\HSVar{t}}\;\HSVar{u}}, we
know \ensuremath{\HSVar{u}\HSSym{\equiv} \HV{\alpha}\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}. We must prove that \ensuremath{\HV{\alpha}}
substitutes all variables in \ensuremath{\pins{\HSVar{p}}} for terms to conclude the proof.
That is simple considering that \ensuremath{\HV{\alpha}\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}\HSSym{\equiv} \HV{\alpha}\;\HSVar{t}}, 
\ensuremath{\vars{\HSVar{t}}\HSSym{\equiv} \emptyset}; this means \ensuremath{\HV{\alpha}} must substitute all
the variables in \ensuremath{\pdel{\HSVar{p}}} for subterms of \ensuremath{\HSVar{t}}, which also contain 
no variables. Finally, since \ensuremath{\HSVar{p}} is a patch, we have that and \ensuremath{\HSSpecial{(}\vars{\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}\HSSpecial{)}\;\subseteq\;\HSSpecial{(}\vars{\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}}\HSSpecial{)}}, which yields that \ensuremath{\vars{\HSSpecial{(}\HV{\alpha}\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}\HSSpecial{)}}\HSSym{\equiv} \emptyset}.
\end{proof}

  With a notion of application at hand, we can define an extensional
equality for our patches. We say patches $p$ and $q$ are equal,
denoted \ensuremath{\HSVar{p}\sim\HSVar{q}}, whenever \ensuremath{\HSSpecial{(}\app{\HSVar{p}}{\HSVar{t}}\;\HSVar{u}\HSSpecial{)}\;\iff\;\HSSpecial{(}\app{\HSVar{q}}{\HSVar{t}}\;\HSVar{u}\HSSpecial{)}}, for all \ensuremath{\HSVar{t}\HSSpecial{,}\HSVar{u}}. It is easy to prove this gives rise to an equivalence
relation. Moreover, it correctly identifies patches equal up to
renaming of variables.

  The next step in constructing an algebra of patches, is to study
the composition of patches. \victor{hint at optimality problems?}
Given patches $p$ and $q$, however, they are not always composable.
Take \ensuremath{\HSVar{p}\HSSym{\mathrel{=}}\patch{\HSCon{Bin}\;\HSVar{x}\;\HSVar{y}}{\HSCon{Bin}\;\HSVar{y}\;\HSVar{x}}} and \ensuremath{\HSVar{q}\HSSym{\mathrel{=}}\patch{\HT{Lea\!f}}{\HSCon{Bin}\;\HT{Lea\!f}\;\HT{Lea\!f}}},
\ensuremath{\after{\HSVar{p}}{\HSVar{q}}} is defined as \ensuremath{\patch{\HT{Lea\!f}}{\HT{Lea\!f}}}, but \ensuremath{\after{\HSVar{q}}{\HSVar{p}}} cannot be defined:
the result of \ensuremath{\HSVar{p}} has a \ensuremath{\HSCon{Bin}} at its head where \ensuremath{\HSVar{q}} expects a \ensuremath{\HT{Lea\!f}}.

\begin{mydef}[Composition]
Let \ensuremath{\HSVar{p}} and \ensuremath{\HSVar{q}} be patches, we say \ensuremath{\HSVar{p}} composes with \ensuremath{\HSVar{q}},
denoted \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}}, whenever \ensuremath{\pdel{\HSVar{p}}} is unifiable with \ensuremath{\pins{\HSVar{q}}}.
Assume \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}} and let \ensuremath{\sigma} be the most general unifier
for \ensuremath{\pdel{\HSVar{p}}} and \ensuremath{\pins{\HSVar{q}}}. We define \ensuremath{\after{\HSVar{p}}{\HSVar{q}}} as:

\begingroup\par\noindent\advance\leftskip\mathindent\(
\begin{pboxed}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\after{\HSVar{p}}{\HSVar{q}}\triangleq\patch{\sigma\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}}{\sigma\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}{}\<[E]%
\ColumnHook
\end{pboxed}
\)\par\noindent\endgroup\resethooks
\end{mydef}

  In order to prove correctness of composition, we must rely on our
assumption that variable names never clash. That is, for any two patches
\ensuremath{\HSVar{p}} and \ensuremath{\HSVar{q}}, \ensuremath{\vars{\HSVar{p}}\;\mathbin{\HS{\cap}}\;\vars{\cdot }\;\HSVar{q}\HSSym{\equiv} \emptyset}. In fact, this
gives rise to a handy lemma.

\begin{lemma}\label{lemma:disjsupcomp}
  Let \ensuremath{\HSVar{p}} and \ensuremath{\HSVar{q}} be composable patches, that is, \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}}. Let
\ensuremath{\sigma} be the most general unifier of \ensuremath{\pdel{\HSVar{p}}} and \ensuremath{\pins{\HSVar{q}}}, witnessing
\ensuremath{\comp{\HSVar{p}}{\HSVar{q}}}. Then, \ensuremath{\sigma\HSSym{\mathrel{=}}\sigma_p\;\cup\;\sigma_q} and \ensuremath{\sigma_p\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}\HSSym{\equiv} \sigma_q\;\HSSpecial{(}\HSVar{qins}\;\HSVar{q}\HSSpecial{)}}.
\end{lemma}
\begin{proof}
Immediate since patches have disjoint sets of variables.
\end{proof}

\begin{lemma}
  Let \ensuremath{\HSVar{p}} and \ensuremath{\HSVar{q}} be patches such that \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}}. Then,
for all \ensuremath{\HSVar{t}\HSSpecial{,}\HSVar{u}}, \ensuremath{\app{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{t}}\HSSym{\mathrel{=}}\HSVar{u}} if and only if \ensuremath{\app{\HSVar{q}}{\HSVar{t}}\HSSym{\mathrel{=}}\HSVar{w}\HSSym{\mathrel{\wedge}}\app{\HSVar{p}}{\HSVar{w}}\HSSym{\mathrel{=}}\HSVar{u}}, for some \ensuremath{\HSVar{w}}. 
\end{lemma}
\begin{proof}
Let us prove the $(\Leftarrow)$ part of equivalence in detail.
Assume \ensuremath{\exists\;\sigma_p\HSSpecial{,}\sigma_q} such that \ensuremath{\sigma_q\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}\HSSym{\equiv} \HSVar{t}}
and \ensuremath{\sigma_p\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}\HSSym{\equiv} \sigma_q\;\HSSpecial{(}\pins{\HSVar{q}}\HSSpecial{)}\HSSym{\equiv} \HSVar{w}}. The proof follows
in four steps.

\begin{enumerate}
\item \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}} can be witnessed by \ensuremath{\sigma_p\;\cup\;\sigma_q}.
\begin{align*}
      & \ensuremath{\HSSpecial{(}\sigma_p\;\cup\;\sigma_q\HSSpecial{)}\;\HSSpecial{(}\pins{\HSVar{q}}\HSSpecial{)}\HSSym{\equiv} \HSSpecial{(}\sigma_p\;\cup\;\sigma_q\HSSpecial{)}\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}} & \\
 \iff & \ensuremath{\sigma_q\;\HSSpecial{(}\pins{\HSVar{q}}\HSSpecial{)}\HSSym{\equiv} \sigma_p\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}} & (\Cref{lemma:disjsupcomp})\\
 \iff & \ensuremath{\HSVar{hyp}}
\end{align*}

\item Now that we proved \ensuremath{\pins{\HSVar{q}}} and \ensuremath{\pdel{\HSVar{p}}} are unifiable, let \ensuremath{\sigma} be their
most general unifier. This means there exists \ensuremath{\gamma} such that \ensuremath{\HSSpecial{(}\sigma_p\;\cup\;\sigma_q\HSSpecial{)}\HSSym{\mathrel{=}}\gamma\HSSym{\mathbin{\circ}}\sigma}.

\item Next, we prove \ensuremath{\sigma\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}} unifies with \ensuremath{\HSVar{t}}, in order
to state \ensuremath{\app{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{t}}}. In fact, \ensuremath{\gamma} above witnesses this fact.
\begin{align*}
      & \ensuremath{\gamma\;\HSVar{t}\HSSym{\equiv} \gamma\;\HSSpecial{(}\sigma\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}\HSSpecial{)}} & \\
 \iff & \ensuremath{\gamma\;\HSVar{t}\HSSym{\equiv} \HSSpecial{(}\gamma\HSSym{\mathbin{\circ}}\sigma\HSSpecial{)}\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}} & \\
 \iff & \ensuremath{\gamma\;\HSVar{t}\HSSym{\equiv} \HSSpecial{(}\sigma_p\;\cup\;\sigma_q\HSSpecial{)}\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}} & \\
 \iff & \ensuremath{\gamma\;\HSVar{t}\HSSym{\equiv} \sigma_q\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}} & (\Cref{lemma:disjsupcomp}) \\
 \iff & \ensuremath{\HSVar{t}\HSSym{\equiv} \sigma_q\;\HSSpecial{(}\pdel{\HSVar{q}}\HSSpecial{)}} & \ensuremath{\HSSpecial{\HSSym{\{\mskip1.5mu} }\HSVar{t}\;\HSVar{is}\;\HSVar{term}\HSSpecial{\HSSym{\mskip1.5mu\}}}}\\
 \iff & \ensuremath{\HSVar{hyp}}
\end{align*}

\item Finally we need that \ensuremath{\gamma\;\HSSpecial{(}\sigma\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}\HSSpecial{)}\HSSym{\equiv} \sigma_p\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}
to conclude the lemma. Again, because the supports of
\ensuremath{\sigma_p} and \ensuremath{\sigma_q} are disjoint, \ensuremath{\sigma_p\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}\HSSym{\equiv} \HSSpecial{(}\sigma_p\;\cup\;\sigma_q\HSSpecial{)}\;\HSSpecial{(}\pins{\HSVar{p}}\HSSpecial{)}}.
Step (2) above concludes the proof.
\end{enumerate}

The $(\Rightarrow)$ side of the equivalence is easier.
Let \ensuremath{\sigma} witness \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}} and \ensuremath{\gamma} witness \ensuremath{\app{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{t}}\;\HSVar{u}}.
Construct \ensuremath{\HSVar{w}} as \ensuremath{\HSSpecial{(}\gamma\HSSym{\mathbin{\circ}}\sigma\HSSpecial{)}\;\HSSpecial{(}\pins{\HSVar{q}}\HSSpecial{)}} and apply analogous reasoning.
\end{proof}

  With correctness of composition out of the way, we move on to
proving that our composition operation abides by the same laws
one would expect out of compositions: they have an identity and
are associative.

\begin{lemma}
For any patch $p$, the identity patch \ensuremath{\patch{\HSVar{x}}{\HSVar{x}}} is a left and right
identity to patch composition, that is, \ensuremath{\after{\HSVar{p}}{\HSSpecial{(}\patch{\HSVar{x}}{\HSVar{x}}\HSSpecial{)}}\sim\HSVar{p}} and
\ensuremath{\after{\HSSpecial{(}\patch{\HSVar{x}}{\HSVar{x}}\HSSpecial{)}}{\HSVar{p}}\sim\HSVar{p}}.
\end{lemma}
\begin{proof}
trivial
\end{proof}

\begin{lemma}\label{lemma:idemp}
  Let \ensuremath{\HSVar{p}} and \ensuremath{\HSVar{q}} be composable patches, let \ensuremath{\sigma\HSSym{\mathrel{=}}\HSVar{mgu}\;\HSSpecial{(}\pdel{\HSVar{p}}\HSSpecial{)}\;\HSSpecial{(}\pins{\HSVar{q}}\HSSpecial{)}}.
Then, \ensuremath{\sigma} is idempotent in \ensuremath{\pdel{\HSVar{p}}} and \ensuremath{\pins{\HSVar{q}}}, that is, \ensuremath{\sigma\;\HSSpecial{(}\sigma\;\HSVar{x}\HSSpecial{)}\HSSym{\mathrel{=}}\sigma\;\HSVar{x}}
for \ensuremath{\HSVar{x}} to be \ensuremath{\pdel{\HSVar{p}}} or \ensuremath{\pins{\HSVar{q}}}.
\end{lemma}
\begin{proof}
I think it is standard that mgu's are idenpotent; but I proved it in
my notebook anyway; can transcribe if needed.
\end{proof}

  Finally, we can prove the associativity of our composition operation.
  
\begin{lemma}
Let $p$ and $q$ be composable patches. Let $r$ be a patch composable
with \ensuremath{\after{\HSVar{p}}{\HSVar{q}}}. Then, $q$ and $r$ are composable and $p$ and \ensuremath{\after{\HSVar{q}}{\HSVar{r}}}
are composable.
\end{lemma}
\begin{proof}
\victor{transcribe}
\end{proof}
  
\begin{lemma}
Let $q$ and $r$ be composable patches. Let $p$ be a patch such that
with \ensuremath{\comp{\HSVar{p}}{\HSSpecial{(}\after{\HSVar{q}}{\HSVar{r}}\HSSpecial{)}}}. Then, \ensuremath{\comp{\HSVar{p}}{\HSVar{q}}} composable and \ensuremath{\comp{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{r}}}.
\end{lemma}
\begin{proof}
\victor{transcribe}
\end{proof}

  
\begin{lemma}
Let \ensuremath{\HSVar{p}\HSSpecial{,}\HSVar{q}} and \ensuremath{\HSVar{r}} be composable patches, \ensuremath{\HSSpecial{(}\after{\HSSpecial{(}\after{\HSVar{p}}{\HSVar{q}}\HSSpecial{)}}{\HSVar{r}}\HSSpecial{)}\sim\HSSpecial{(}\after{\HSVar{p}}{\HSSpecial{(}\after{\HSVar{q}}{\HSVar{r}}\HSSpecial{)}}\HSSpecial{)}}
\end{lemma}
\begin{proof}
\victor{transcribe}
\end{proof}

\victor{I still have to talk about inverses, which is just swapping the deletion and insertion cotexts.}

  From these results, it follows that patches form a grupoid structure
over $\termsof{L}$, for any $L$.

  Yet, from a pratical standpoint, we composition might obfuscate
potential shares between the source and destination tree.

\section{Merging}

\victor{
\begin{itemize}
\item This construction of patches admits a merge operator.
\end{itemize}
}

\section{Experiments}

\victor{We are up to 30\% success rate on the dataset! yay}

\section{Discussion}

\subsection{The Case Against Inverses}

\victor{Mimram dislikes inverses in the theory, they remove the
ability to use model merges through pushouts}

\subsection{The Case Against \emph{cost}}

\victor{\begin{itemize}
\item Defining the \emph{best} patch is difficult
\item The point of the cost, in ES, is to eliminate 
redundant operations. \ensuremath{\HSVar{cost}\;\HSSpecial{(}\HSVar{del}\;\HSVar{c}\;\HSSpecial{(}\HSVar{ins}\;\HSVar{c}\HSSpecial{)}\HSSpecial{)}\HSSym{\mathrel{=}}\HSNumeral{2}}
whereas \ensuremath{\HSVar{cost}\;\HSSpecial{(}\HSVar{cpy}\;\HSVar{c}\HSSpecial{)}\HSSym{\mathrel{=}}\HSNumeral{0}}
\item In our case, redundant copies might be present
as a byproduct of enforcing the sharing of subtrees.
\item From our experimental results, it seems that
patches that copy larger subtrees, closer to the root,
merge better. Hence, this could better guide a notionof optimality
\item We leave this as future work
\end{itemize}}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: 
%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

%% Bibliography
\bibliography{references}
\end{document}
